{
  "version": "https://jsonfeed.org/version/1",
  "title": "Bugs with Blas",
  "home_page_url": "http://localhost:1313/",
  "feed_url": "http://localhost:1313/feed.json",
  "description": "Hi, I'm Błażej Gutowski, and this is my personal portfolio and blog. After several years of experience as an IT administrator, I've transitioned into the exciting field of cybersecurity. Here, you'll find insights into my journey as a penetration tester, my professional portfolio, and a collection of blog posts covering topics like pentesting, vulnerability research, and bug hunting.",
  "favicon": "http://localhost:1313//assets/favicon.ico",
  "expired": false,
  "author": {
    "name": "Blazej Gutowski",
    "url": "http://localhost:1313/"
  },
  "items": [
    
    

    
    {
      "id": "886523cefe195b429bb9286372f5bd33ed7cf8b3",
      "title": "Understanding Request Smuggling",
      "summary": "HTTP request smuggling is a powerful attack that exploits inconsistencies in how front-end and back-end servers parse HTTP requests. This article provides a deep dive into the fundamentals, covering key HTTP headers like Content-Length and Transfer-Encoding, and explaining how parsing discrepancies create security risks. We explore how modern web architectures contribute to these vulnerabilities and demonstrate both manual and automated.",
      "content_text": "1. Introduction As I was preparing to pass the BSCP exam, the most challenging and unfamiliar type of vulnerability for me was HTTP request smuggling.\nTo fully understand this attack, it is essential to grasp the fundamentals of the HTTP protocol and how modern web applications are structured, particularly regarding proxy servers, load balancers, and back-end architecture. In this article, I will expand my knowledge by exploring every aspect of this vulnerability.\nFor someone unfamiliar with this attack, request smuggling exploits discrepancies in how HTTP requests are parsed between front-end and back-end servers. The goal is to manipulate request boundaries, often causing one request to be interpreted as two separate ones. How is this accomplished? Why does this happen? These are the questions I will attempt to answer.\u0026quot;\nThe impact of request smuggling varies depending on the web application\u0026rsquo;s infrastructure and security controls. In some cases, it can allow an attacker to bypass authentication, access restricted resources, or hijack user sessions—posing a serious security risk.\n2. Understanding Core HTTP Headers in Request Smuggling Before diving into attack techniques, it’s important to understand the headers that play a crucial role in HTTP request parsing.\nBut first, when were these headers introduced, and what problems did they solve? HTTP/1.1 was introduced in 1997 to address some of the issues in version 1.0. The main problem with HTTP/1.0 was its inefficiency—each request required a full 3-way handshake before it could be processed. Additionally, it lacked built-in support for persistent connections and caching mechanisms. One of the solutions introduced in HTTP/1.1 was the Transfer-Encoding header, which helped improve efficiency in data transmission.\nKey HTTP Headers Relevant to Request Smuggling Connection and Keep-Alive While the Content-Length and Transfer-Encoding headers specify message lengths, the Connection and Keep-Alive headers allow a connection to remain open for multiple requests, reducing the need for a 3-way handshake with every request.\nThe Connection header has two primary options:\nkeep-alive (default in HTTP/1.1): Keeps the connection open for subsequent requests. close: Closes the connection after the response is sent. The Keep-Alive header specifies the number of requests allowed before the connection is closed and the duration for which an idle connection remains open.\nExample:\nKeep-Alive: timeout=5, max=200 This means the connection will remain open for up to 5 seconds and allow up to 200 requests before closing.\nContent-Length What is the format of Content-Length, and why is it used?\nAccording to RFC 9110, Content-Length represents the length of the message body as a decimal, non-negative integer (measured in octets).\nWhy is this necessary?\nIt allows recipients to determine when a message is complete and track its progress. One important detail from RFC 9112 states that:\nIf a message does not have a Transfer-Encoding header, then Content-Length defines its length. A sender MUST NOT include a Content-Length header in a message that also contains a Transfer-Encoding header. Transfer-Encoding As specified in RFC 9112, the Transfer-Encoding header defines how the message body is encoded for transfer. The most common value is chunked encoding.\nHow does chunked encoding work?\nThe body is sent in a series of chunks. Each chunk begins with its size in hexadecimal, followed by the actual data. A chunk of size 0 signals the end of the message. This encoding enables:\nProgressive processing (recipients can start handling data before receiving the full message). Dynamic content transmission (useful when the final content size is unknown). Persistent connections (keep-alive), improving HTTP efficiency. Handling Transfer-Encoding and Content-Length in HTTP Even though the specification states that a sender MUST NOT include a Content-Length header in a message that also contains a Transfer-Encoding header, this is not always enforced in practice. This issue was resolved in HTTP/2, where Transfer-Encoding is no longer used.\nWhat happens if both headers are present in a request? Part 6.3 of RFC 9112 discusses a potential attack scenario and provides guidance on handling such cases. Specifically, point 3 states:\nIf a message is received with both a Transfer-Encoding and a Content-Length header field, the Transfer-Encoding overrides the Content-Length. Such a message might indicate an attempt to perform request smuggling (Section 11.2) or response splitting (Section 11.1) and ought to be handled as an error. An intermediary that chooses to forward the message MUST first remove the received Content-Length field and process the Transfer-Encoding (as described below) prior to forwarding the message downstream.\nThus, the specification mandates that servers must be aware of both headers. If both are present, the Content-Length header should be removed to prevent misinterpretation.\nWhy is this a security concern? When the HTTP specification was initially created in 1997, infrastructures were simpler, and most websites were handled by a single server. However, modern web architectures rely on multiple components such as proxies, load balancers, and security gateways. Some of these components do not fully support Transfer-Encoding, or they may interpret conflicting headers differently.\nThis inconsistency in how different servers and intermediaries handle these headers creates an opportunity for HTTP request smuggling attacks. In such attacks, an adversary manipulates headers to cause a server to interpret requests differently from downstream components, potentially leading to security breaches such as cache poisoning, unauthorized request execution, or bypassing authentication mechanisms.\n3. Identification At this stage, what do we know? For this vulnerability to occur, multiple servers must be in a request chain, and they must handle headers inconsistently.\nThe first step is to enumerate proxy servers using tools like traceroute or nslookup. Additionally, the presence of headers like Via or X-Forwarded-For may indicate a multi-hop setup involving proxies or load balancers.\nUsing Burp Suite, the HTTP Request Smuggler extension can automatically send crafted requests to detect vulnerabilities. But what happens under the hood?\nBasic Attack Techniques Before we proceed, let\u0026rsquo;s go over the three primary types of HTTP request smuggling attacks:\nCL.TE (Content-Length vs. Transfer-Encoding mismatch) The frontend server processes Content-Length (CL), while the backend server processes Transfer-Encoding (TE). TE.CL (Transfer-Encoding vs. Content-Length mismatch) The reverse of the above: the frontend processes Transfer-Encoding, while the backend relies on Content-Length. TE.TE (Two conflicting Transfer-Encoding headers) Different servers in the chain handle the multiple Transfer-Encoding headers inconsistently. There are some prerequisites for identifying these vulnerabilities:\nThe attack surface applies only to HTTP/1.1. In Burp Suite, navigate to Repeater, switch the HTTP version to 1.1, and verify whether the request is supported. Enable the option to display non-printable characters. You\u0026rsquo;ll see \\r\\n (Carriage Return + Line Feed) at the end of each line. HTTP follows legacy Telnet/MIME standards, where \\r\\n marks the start of a new line. An additional \\r\\n after the headers marks the transition between headers and the request body. Understanding Chunked Encoding Before testing, it\u0026rsquo;s important to understand the chunked transfer encoding format. According to the HTTP specification, a chunked body is structured as follows:\nchunked-body = *chunk last-chunk trailer-section CRLF chunk = chunk-size CRLF chunk-data CRLF The chunk size is a hexadecimal value specifying the length of the chunk data. The trailer section may contain additional headers, but for this test, we will ignore them. A correctly formatted chunked body looks like this:\n3\\r\\n abc\\r\\n 0\\r\\n \\r\\n Where first chunk of size 3 sends value abc and next chunk with size 0 and CRLF at next line tells server that it\u0026rsquo;s last chunk.\nNow, let’s proceed with testing.\nIdentifying the Vulnerability\nTo test for request smuggling, send the following request:\nContent-Length: 6 Transfer-Encoding: chunked \\r\\n 3\\r\\n abc\\r\\n X\\r\\n \\r\\n Here’s what\u0026rsquo;s happening:\nThe body has 13 bytes, but the Content-Length: 6 header tells the server to expect only 6 bytes. The presence of X after abc may reveal an inconsistency in how the frontend and backend interpret the request.\nPossible Responses\nImmediate rejection: The frontend correctly recognizes Transfer-Encoding: chunked and interprets X as an invalid chunk size (not hexadecimal).This suggests the server correctly processes TE. But we cannot say how backend is reacting. In this situation is either TE.CL or TE.TE Correct response: This means the frontend and backend both rely on Content-Length, making the application resistant to request smuggling. Timeout: The backend ignores Content-Length, interprets abc as a chunk, but fails on X, as it\u0026rsquo;s not a valid chunk size. The backend waits indefinitely for a valid chunk size, which never arrives. This indicates a TE.CL vulnerability. Confirming TE.TE vs. TE.CL\nTo determine whether the application is vulnerable to TE.TE or TE.CL, send a second request:\nContent-Length: 6 Transfer-Encoding: chunked \\r\\n 0\\r\\n \\r\\n X Possible Responses\nCorrect response: This suggests either TE.TE or CL.CL handling. CL.TE behavior: The frontend forwards the entire body, but the backend leaves X in the buffer. If a follow-up request is sent, it may cause an invalid method error like XPOST, showing that X was treated as the beginning of the next request. Timeout: The frontend ignores Content-Length, meaning X is never sent. The backend expects a total body length of 6 but never receives it. This confirms a TE.CL vulnerability. Automatic Identification\nI showed you how to manually test applications with those two requests. But it\u0026rsquo;s done by the Burp Suite extension HTTP Request Smuggler. To run the extension, right-click on the request and Extensions -\u0026gt; HTTP Request Smuggler -\u0026gt; Smuggle Probe. In the target tab, I got the message:\n\u0026ldquo;Possible HTTP Request Smuggling: CL.TE multiCase (delayed response).\u0026rdquo;\nAnd in one of the requests below, it\u0026rsquo;s a request similar to those shown above:\nContent-Length: 13 tRANSFER-ENCODING: chunked \\r\\n 3\\r\\n x=y\\r\\n 1\\r\\n Z\\r\\n Q\\r\\n \\r\\n The response from this request is a timeout. Why is it suggesting it\u0026rsquo;s CL.TE? Similar to the previous case, the frontend completely ignores TE, but the backend does not. As it gets Q as a chunk size, it waits for the proper value and responds with a timeout.\nContent-Length: 14 tRANSFER-ENCODING: chunked \\r\\n 3\\r\\n x=y\\r\\n 0\\r\\n \\r\\n X This time, automatic detection for TE.CL occurs. A very similar approach is used. The frontend ignores X as it uses TE and detects the last chunk. The backend, however, waits for the 14th byte based on the CL value but never receives it, resulting in a timeout.\nDetecting TE.TE\nAs we showed above, TE.TE can be successfully detected with the first two requests. This situation happens when both the backend and frontend use TE, and we can obfuscate headers to force one of the servers not to process it. As explained on PortSwigger Academy:\n\u0026ldquo;Each of these techniques involves a subtle departure from the HTTP specification. Real-world code that implements a protocol specification rarely adheres to it with absolute precision, and it is common for different implementations to tolerate different variations from the specification.\u0026rdquo;\nSo it\u0026rsquo;s up to the attacker to find subtle differences that allow a header to be ignored. As you can see in the example above from the extension, it uses an obfuscation technique by changing all the characters to uppercase except the first letter: tRANSFER-ENCODING: chunked. The extension tries to perform multiple identifications at once, so it combines multiple techniques into a single request.\nThere are many techniques to obfuscate the TE header. Here are a couple of them:\nTransfer-Encoding: xchunked Transfer-Encoding: x Transfer-Encoding:[tab]chunked [space]Transfer-Encoding: chunked X: X[\\n]Transfer-Encoding: chunked Transfer-Encoding : chunked Transfer-encoding: identity Transfer-encoding: cow tRANSFER-ENCODING: chunked 4. HTTP/2 Request Smuggling HTTP/2, while maintaining the same methods, status codes, and headers as its predecessor, fundamentally changes how data is formatted and transmitted. Unlike the text-based HTTP/1, HTTP/2 is a binary protocol, sending data as a collection of 0s and 1s. In the context of request smuggling, it\u0026rsquo;s crucial to note that HTTP/2 doesn\u0026rsquo;t use Transfer-Encoding or Content-Length headers in the same way. Instead, each frame specifies its length in bytes at the beginning, as defined in the HTTP/2 frame format\nHttp2 downgrading The vulnerability of HTTP/2 to request smuggling primarily stems from the process of HTTP/2 downgrading. Many organizations implement this downgrading for backward compatibility with legacy backend systems that haven\u0026rsquo;t yet transitioned to HTTP/2. This flexibility allows administrators to maintain access to older systems while using modern frontend solutions.\nHowever, this backward compatibility introduces security risks. When downgrading occurs, the backend loses access to the HTTP/2 frame length value, potentially allowing the injection of HTTP/1 headers.\nH2.CL and H2.TE In HTTP/2, requests use pseudo-headers instead of the traditional request line. For example, the path is represented by the :path pseudo-header, and the Host header is replaced by :authority. Here\u0026rsquo;s an example of how an attacker might attempt to smuggle a request:\n:method POST :path /test :authority example.com content-type application/x-www-form-urlencoded transfer-encoding chunked 0 GET /admin HTTP/1.1 Host: example.com Foo: Injected When downgraded to HTTP/1.1, this request might look like:\nPOST /test HTTP/1.1 Host: example.com Content-Type: application/x-www-form-urlencoded Transfer-Encoding: chunked 0 GET /admin HTTP/1.1 Host: example.com Foo: Injected In this scenario, the backend might interpret the body as a zero-length chunk, treating the rest as the beginning of a new request. This could potentially allow access to restricted paths like /admin.\nSimilarly, an attacker could attempt to inject a Content-Length header:\n:method POST :path / :authority example.com content-type application/x-www-form-urlencoded content-length 0 GET /admin HTTP/1.1 Host: example.com When downgraded, this becomes:\nPOST / HTTP/1.1 Host: example.com Content-Type: application/x-www-form-urlencoded Content-Length: 0 GET /admin HTTP/1.1 Host: example.com Here, the body of the request might be ignored due to the Content-Length being set to zero, potentially allowing the smuggled request to be processed.\nThere are many of possible injections points you can try, there is a great article about it by James Kettle: HTTP/2: The Sequel is Always Worse. In this article i want to just show basic mechanism.\nConclusion We’ve established a solid foundation for understanding HTTP request smuggling. We’ve examined essential HTTP headers, analyzed how discrepancies between front-end and back-end processing can introduce vulnerabilities, and explored both manual and automated methods for detecting these issues. A key aspect of this is understanding the role of Content-Length and Transfer-Encoding in request handling.\nUnderstanding HTTP/2 request smuggling requires knowledge of how HTTP/2 differs from HTTP/1, particularly in terms of data formatting and transmission. The vulnerability primarily arises from the downgrading process implemented for backward compatibility. By manipulating headers and taking advantage of how different servers interpret requests, attackers can potentially smuggle requests even in HTTP/2 environments.\n",
      "content_html": "\u003ch2 id=\"1-introduction\"\u003e1. Introduction\u003c/h2\u003e\n\u003cp\u003eAs I was preparing to pass the BSCP exam, the most challenging and unfamiliar type of vulnerability for me was HTTP request smuggling.\u003c/p\u003e\n\u003cp\u003eTo fully understand this attack, it is essential to grasp the fundamentals of the HTTP protocol and how modern web applications are structured, particularly regarding proxy servers, load balancers, and back-end architecture. In this article, I will expand my knowledge by exploring every aspect of this vulnerability.\u003c/p\u003e\n\u003cp\u003eFor someone unfamiliar with this attack, request smuggling exploits discrepancies in how HTTP requests are parsed between front-end and back-end servers. The goal is to manipulate request boundaries, often causing one request to be interpreted as two separate ones. How is this accomplished? Why does this happen? These are the questions I will attempt to answer.\u0026quot;\u003c/p\u003e\n\u003cp\u003eThe impact of request smuggling varies depending on the web application\u0026rsquo;s infrastructure and security controls. In some cases, it can allow an attacker to bypass authentication, access restricted resources, or hijack user sessions—posing a serious security risk.\u003c/p\u003e\n\u003ch2 id=\"2-understanding-core-http-headers-in-request-smuggling\"\u003e2. Understanding Core HTTP Headers in Request Smuggling\u003c/h2\u003e\n\u003cp\u003eBefore diving into attack techniques, it’s important to understand the headers that play a crucial role in HTTP request parsing.\u003c/p\u003e\n\u003cp\u003eBut first, when were these headers introduced, and what problems did they solve? \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Evolution_of_HTTP#http1.1_%E2%80%93_the_standardized_protocol\"\u003eHTTP/1.1\u003c/a\u003e was introduced in 1997 to address some of the issues in version 1.0. The main problem with HTTP/1.0 was its inefficiency—each request required a full \u003cstrong\u003e3-way handshake\u003c/strong\u003e before it could be processed. Additionally, it lacked built-in support for persistent connections and caching mechanisms. One of the solutions introduced in HTTP/1.1 was the Transfer-Encoding header, which helped improve efficiency in data transmission.\u003c/p\u003e\n\u003ch3 id=\"key-http-headers-relevant-to-request-smuggling\"\u003e\u003cstrong\u003eKey HTTP Headers Relevant to Request Smuggling\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4 id=\"connection-and-keep-alive\"\u003e\u003cstrong\u003eConnection and Keep-Alive\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003eWhile the Content-Length and Transfer-Encoding headers specify message lengths, the Connection and Keep-Alive headers allow a connection to remain open for multiple requests, reducing the need for a \u003cstrong\u003e3-way handshake\u003c/strong\u003e with every request.\u003c/p\u003e\n\u003cp\u003eThe Connection header has two primary options:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ekeep-alive\u003c/strong\u003e (default in HTTP/1.1): Keeps the connection open for subsequent requests.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eclose\u003c/strong\u003e: Closes the connection after the response is sent.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe Keep-Alive header specifies the number of requests allowed before the connection is closed and the duration for which an idle connection remains open.\u003cbr\u003e\nExample:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eKeep-Alive: \u003cspan style=\"color:#111\"\u003etimeout\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e5, \u003cspan style=\"color:#111\"\u003emax\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e200\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThis means the connection will remain open for up to 5 seconds and allow up to 200 requests before closing.\u003c/p\u003e\n\u003ch4 id=\"content-length\"\u003e\u003cstrong\u003eContent-Length\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003eWhat is the format of Content-Length, and why is it used?\u003c/p\u003e\n\u003cp\u003eAccording to \u003cstrong\u003e\u003ca href=\"https://httpwg.org/specs/rfc9110.html#field.content-length\"\u003eRFC 9110\u003c/a\u003e\u003c/strong\u003e, Content-Length represents the length of the message body as a \u003cstrong\u003edecimal, non-negative integer\u003c/strong\u003e (measured in octets).\u003c/p\u003e\n\u003cp\u003eWhy is this necessary?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIt allows recipients to determine when a message is complete and track its progress.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOne important detail from \u003cstrong\u003e\u003ca href=\"https://httpwg.org/specs/rfc9112.html#body.content-length\"\u003eRFC 9112\u003c/a\u003e\u003c/strong\u003e states that:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf a message \u003cstrong\u003edoes not\u003c/strong\u003e have a Transfer-Encoding header, then Content-Length defines its length.\u003c/li\u003e\n\u003cli\u003eA sender \u003cstrong\u003eMUST NOT\u003c/strong\u003e include a Content-Length header in a message that also contains a Transfer-Encoding header.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"transfer-encoding\"\u003e\u003cstrong\u003eTransfer-Encoding\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003eAs specified in \u003cstrong\u003e\u003ca href=\"https://httpwg.org/specs/rfc9112.html#field.transfer-encoding\"\u003eRFC 9112\u003c/a\u003e\u003c/strong\u003e, the Transfer-Encoding header defines how the message body is encoded for transfer. The most common value is \u003cstrong\u003echunked\u003c/strong\u003e encoding.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow does chunked encoding work?\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe body is sent in a series of chunks.\u003c/li\u003e\n\u003cli\u003eEach chunk begins with its \u003cstrong\u003esize in hexadecimal\u003c/strong\u003e, followed by the actual data.\u003c/li\u003e\n\u003cli\u003eA chunk of size 0 signals the end of the message.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis encoding enables:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eProgressive processing\u003c/strong\u003e (recipients can start handling data before receiving the full message).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDynamic content transmission\u003c/strong\u003e (useful when the final content size is unknown).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePersistent connections\u003c/strong\u003e (keep-alive), improving HTTP efficiency.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"handling-transfer-encoding-and-content-length-in-http\"\u003eHandling Transfer-Encoding and Content-Length in HTTP\u003c/h2\u003e\n\u003cp\u003eEven though the specification states that a sender \u003cstrong\u003eMUST NOT\u003c/strong\u003e include a Content-Length header in a message that also contains a Transfer-Encoding header, this is not always enforced in practice. This issue was resolved in HTTP/2, where Transfer-Encoding is no longer used.\u003c/p\u003e\n\u003ch3 id=\"what-happens-if-both-headers-are-present-in-a-request\"\u003eWhat happens if both headers are present in a request?\u003c/h3\u003e\n\u003cp\u003ePart \u003cstrong\u003e\u003ca href=\"https://httpwg.org/specs/rfc9112.html#message.body.length\"\u003e6.3\u003c/a\u003e\u003c/strong\u003e of RFC 9112 discusses a potential attack scenario and provides guidance on handling such cases. Specifically, point 3 states:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eIf a message is received with both a Transfer-Encoding and a Content-Length header field, the Transfer-Encoding overrides the Content-Length. Such a message might indicate an attempt to perform request smuggling (Section 11.2) or response splitting (Section 11.1) and ought to be handled as an error. An intermediary that chooses to forward the message MUST first remove the received Content-Length field and process the Transfer-Encoding (as described below) prior to forwarding the message downstream.\u003c/strong\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThus, the specification mandates that servers must be aware of both headers. If both are present, the Content-Length header should be removed to prevent misinterpretation.\u003c/p\u003e\n\u003ch3 id=\"why-is-this-a-security-concern\"\u003eWhy is this a security concern?\u003c/h3\u003e\n\u003cp\u003eWhen the HTTP specification was initially created in 1997, infrastructures were simpler, and most websites were handled by a single server. However, modern web architectures rely on multiple components such as proxies, load balancers, and security gateways. Some of these components do not fully support Transfer-Encoding, or they may interpret conflicting headers differently.\u003c/p\u003e\n\u003cp\u003eThis inconsistency in how different servers and intermediaries handle these headers creates an opportunity for \u003cstrong\u003eHTTP request smuggling attacks\u003c/strong\u003e. In such attacks, an adversary manipulates headers to cause a server to interpret requests differently from downstream components, potentially leading to security breaches such as cache poisoning, unauthorized request execution, or bypassing authentication mechanisms.\u003c/p\u003e\n\u003ch2 id=\"3-identification\"\u003e3. Identification\u003c/h2\u003e\n\u003cp\u003eAt this stage, what do we know? For this vulnerability to occur, multiple servers must be in a request chain, and they must handle headers inconsistently.\u003c/p\u003e\n\u003cp\u003eThe first step is to enumerate proxy servers using tools like traceroute or nslookup. Additionally, the presence of headers like Via or X-Forwarded-For may indicate a multi-hop setup involving proxies or load balancers.\u003c/p\u003e\n\u003cp\u003eUsing Burp Suite, the HTTP Request Smuggler extension can automatically send crafted requests to detect vulnerabilities. But what happens under the hood?\u003c/p\u003e\n\u003ch3 id=\"basic-attack-techniques\"\u003e\u003cstrong\u003eBasic Attack Techniques\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003eBefore we proceed, let\u0026rsquo;s go over the three primary types of HTTP request smuggling attacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCL.TE\u003c/strong\u003e (Content-Length vs. Transfer-Encoding mismatch)\nThe frontend server processes Content-Length (CL), while the backend server processes Transfer-Encoding (TE).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTE.CL\u003c/strong\u003e (Transfer-Encoding vs. Content-Length mismatch)\nThe reverse of the above: the frontend processes Transfer-Encoding, while the backend relies on Content-Length.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTE.TE\u003c/strong\u003e (Two conflicting Transfer-Encoding headers)\nDifferent servers in the chain handle the multiple Transfer-Encoding headers inconsistently.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere are some prerequisites for identifying these vulnerabilities:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003col\u003e\n\u003cli\u003eThe attack surface applies only to HTTP/1.1.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eIn Burp Suite, navigate to Repeater, switch the HTTP version to 1.1, and verify whether the request is supported.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003eEnable the option to display non-printable characters. You\u0026rsquo;ll see \u003ccode\u003e\\r\\n\u003c/code\u003e (Carriage Return + Line Feed) at the end of each line. HTTP follows legacy Telnet/MIME standards, where \\r\\n marks the start of a new line.\nAn additional \\r\\n after the headers marks the transition between headers and the request body.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"understanding-chunked-encoding\"\u003e\u003cstrong\u003eUnderstanding Chunked Encoding\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003eBefore testing, it\u0026rsquo;s important to understand the chunked transfer encoding format. According to the HTTP specification, a chunked body is structured as follows:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003echunked-body   \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e *chunk\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                 last-chunk\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                 trailer-section\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                 CRLF\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#111\"\u003echunk\u003c/span\u003e          \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e chunk-size CRLF\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                 chunk-data CRLF\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe chunk size is a hexadecimal value specifying the length of the chunk data.\nThe trailer section may contain additional headers, but for this test, we will ignore them.\nA correctly formatted chunked body looks like this:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e3\u003cspan style=\"color:#8045ff\"\u003e\\r\\n\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eabc\u003cspan style=\"color:#8045ff\"\u003e\\r\\n\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e0\u003cspan style=\"color:#8045ff\"\u003e\\r\\n\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8045ff\"\u003e\\r\\n\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWhere first chunk of size 3 sends value \u003ccode\u003eabc\u003c/code\u003e and next chunk with size 0 and CRLF at next line tells server that it\u0026rsquo;s last chunk.\u003c/p\u003e\n\u003cp\u003eNow, let’s proceed with testing.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eIdentifying the Vulnerability\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eTo test for request smuggling, send the following request:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eContent-Length: \u003cspan style=\"color:#ae81ff\"\u003e6\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eTransfer-Encoding: chunked\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8045ff\"\u003e\\r\\n\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e3\u003cspan style=\"color:#8045ff\"\u003e\\r\\n\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eabc\u003cspan style=\"color:#8045ff\"\u003e\\r\\n\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eX\u003cspan style=\"color:#8045ff\"\u003e\\r\\n\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8045ff\"\u003e\\r\\n\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eHere’s what\u0026rsquo;s happening:\u003c/p\u003e\n\u003cp\u003eThe body has 13 bytes, but the Content-Length: 6 header tells the server to expect only 6 bytes.\nThe presence of X after abc may reveal an inconsistency in how the frontend and backend interpret the request.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ePossible Responses\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003col\u003e\n\u003cli\u003eImmediate rejection: The frontend correctly recognizes Transfer-Encoding: chunked and interprets X as an invalid chunk size (not hexadecimal).This suggests the server correctly processes TE. But we cannot say how backend is reacting. In this situation is either TE.CL or TE.TE\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eCorrect response: This means the frontend and backend both rely on Content-Length, making the application resistant to request smuggling.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003eTimeout: The backend ignores Content-Length, interprets abc as a chunk, but fails on X, as it\u0026rsquo;s not a valid chunk size. The backend waits indefinitely for a valid chunk size, which never arrives. This indicates a TE.CL vulnerability.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eConfirming TE.TE vs. TE.CL\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eTo determine whether the application is vulnerable to TE.TE or TE.CL, send a second request:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eContent-Length: \u003cspan style=\"color:#ae81ff\"\u003e6\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eTransfer-Encoding: chunked\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8045ff\"\u003e\\r\\n\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e0\u003cspan style=\"color:#8045ff\"\u003e\\r\\n\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8045ff\"\u003e\\r\\n\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eX\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003ePossible Responses\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003col\u003e\n\u003cli\u003eCorrect response: This suggests either TE.TE or CL.CL handling.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eCL.TE behavior: The frontend forwards the entire body, but the backend leaves X in the buffer. If a follow-up request is sent, it may cause an invalid method error like XPOST, showing that X was treated as the beginning of the next request.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003eTimeout: The frontend ignores Content-Length, meaning X is never sent. The backend expects a total body length of 6 but never receives it. This confirms a TE.CL vulnerability.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eAutomatic Identification\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI showed you how to manually test applications with those two requests. But it\u0026rsquo;s done by the Burp Suite extension \u003cstrong\u003e\u003ca href=\"https://portswigger.net/bappstore/aaaa60ef945341e8a450217a54a11646\"\u003eHTTP Request Smuggler\u003c/a\u003e\u003c/strong\u003e. To run the extension, right-click on the request and Extensions -\u0026gt; HTTP Request Smuggler -\u0026gt; Smuggle Probe. In the target tab, I got the message:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u0026ldquo;Possible HTTP Request Smuggling: CL.TE multiCase (delayed response).\u0026rdquo;\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eAnd in one of the requests below, it\u0026rsquo;s a request similar to those shown above:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eContent-Length: \u003cspan style=\"color:#ae81ff\"\u003e13\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etRANSFER-ENCODING: chunked\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8045ff\"\u003e\\r\\n\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e3\u003cspan style=\"color:#8045ff\"\u003e\\r\\n\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#111\"\u003ex\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003ey\u003cspan style=\"color:#8045ff\"\u003e\\r\\n\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e1\u003cspan style=\"color:#8045ff\"\u003e\\r\\n\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eZ\u003cspan style=\"color:#8045ff\"\u003e\\r\\n\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eQ\u003cspan style=\"color:#8045ff\"\u003e\\r\\n\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8045ff\"\u003e\\r\\n\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe response from this request is a timeout. Why is it suggesting it\u0026rsquo;s CL.TE? Similar to the previous case, the frontend completely ignores TE, but the backend does not. As it gets Q as a chunk size, it waits for the proper value and responds with a timeout.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eContent-Length: \u003cspan style=\"color:#ae81ff\"\u003e14\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etRANSFER-ENCODING: chunked\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8045ff\"\u003e\\r\\n\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e3\u003cspan style=\"color:#8045ff\"\u003e\\r\\n\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#111\"\u003ex\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003ey\u003cspan style=\"color:#8045ff\"\u003e\\r\\n\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e0\u003cspan style=\"color:#8045ff\"\u003e\\r\\n\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8045ff\"\u003e\\r\\n\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eX\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThis time, automatic detection for TE.CL occurs. A very similar approach is used. The frontend ignores X as it uses TE and detects the last chunk. The backend, however, waits for the 14th byte based on the CL value but never receives it, resulting in a timeout.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eDetecting TE.TE\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eAs we showed above, TE.TE can be successfully detected with the first two requests. This situation happens when both the backend and frontend use TE, and we can obfuscate headers to force one of the servers not to process it. As explained on PortSwigger Academy:\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;Each of these techniques involves a subtle departure from the HTTP specification. Real-world code that implements a protocol specification rarely adheres to it with absolute precision, and it is common for different implementations to tolerate different variations from the specification.\u0026rdquo;\u003c/p\u003e\n\u003cp\u003eSo it\u0026rsquo;s up to the attacker to find subtle differences that allow a header to be ignored. As you can see in the example above from the extension, it uses an obfuscation technique by changing all the characters to uppercase except the first letter: tRANSFER-ENCODING: chunked. The extension tries to perform multiple identifications at once, so it combines multiple techniques into a single request.\u003c/p\u003e\n\u003cp\u003eThere are many techniques to obfuscate the TE header. Here are a couple of them:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eTransfer-Encoding: xchunked\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eTransfer-Encoding: x\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eTransfer-Encoding:\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003etab\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003echunked\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003espace\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003eTransfer-Encoding: chunked\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eX: X\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003e\u003cspan style=\"color:#8045ff\"\u003e\\n\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003eTransfer-Encoding: chunked\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eTransfer-Encoding\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e: chunked\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eTransfer-encoding: identity\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eTransfer-encoding: cow\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etRANSFER-ENCODING: chunked\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"4-http2-request-smuggling\"\u003e4. HTTP/2 Request Smuggling\u003c/h2\u003e\n\u003cp\u003eHTTP/2, while maintaining the same methods, status codes, and headers as its predecessor, fundamentally changes how data is formatted and transmitted. Unlike the text-based HTTP/1, HTTP/2 is a binary protocol, sending data as a collection of 0s and 1s. In the context of request smuggling, it\u0026rsquo;s crucial to note that HTTP/2 doesn\u0026rsquo;t use Transfer-Encoding or Content-Length headers in the same way. Instead, each frame specifies its length in bytes at the beginning, as defined in the HTTP/2  \u003cstrong\u003e\u003ca href=\"https://datatracker.ietf.org/doc/html/rfc7540#section-4.1\"\u003eframe format\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003ch3 id=\"http2-downgrading\"\u003eHttp2 downgrading\u003c/h3\u003e\n\u003cp\u003eThe vulnerability of HTTP/2 to request smuggling primarily stems from the process of HTTP/2 downgrading. Many organizations implement this downgrading for backward compatibility with legacy backend systems that haven\u0026rsquo;t yet transitioned to HTTP/2. This flexibility allows administrators to maintain access to older systems while using modern frontend solutions.\u003c/p\u003e\n\u003cp\u003eHowever, this backward compatibility introduces security risks. When downgrading occurs, the backend loses access to the HTTP/2 frame length value, potentially allowing the injection of HTTP/1 headers.\u003c/p\u003e\n\u003ch3 id=\"h2cl-and-h2te\"\u003eH2.CL and H2.TE\u003c/h3\u003e\n\u003cp\u003eIn HTTP/2, requests use pseudo-headers instead of the traditional request line. For example, the path is represented by the :path pseudo-header, and the Host header is replaced by :authority. Here\u0026rsquo;s an example of how an attacker might attempt to smuggle a request:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e:method POST\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e:path /test\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e:authority example.com\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003econtent-type application/x-www-form-urlencoded\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etransfer-encoding chunked\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eGET /admin HTTP/1.1\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eHost: example.com\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eFoo: Injected\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWhen downgraded to HTTP/1.1, this request might look like:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePOST /test HTTP/1.1\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eHost: example.com\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eContent-Type: application/x-www-form-urlencoded\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eTransfer-Encoding: chunked\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eGET /admin HTTP/1.1\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eHost: example.com\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eFoo: Injected\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIn this scenario, the backend might interpret the body as a zero-length chunk, treating the rest as the beginning of a new request. This could potentially allow access to restricted paths like /admin.\u003c/p\u003e\n\u003cp\u003eSimilarly, an attacker could attempt to inject a Content-Length header:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e:method POST\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e:path /\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e:authority example.com\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003econtent-type application/x-www-form-urlencoded\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003econtent-length \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eGET /admin HTTP/1.1\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eHost: example.com\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWhen downgraded, this becomes:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePOST / HTTP/1.1\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eHost: example.com\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eContent-Type: application/x-www-form-urlencoded\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eContent-Length: \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eGET /admin HTTP/1.1\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eHost: example.com\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eHere, the body of the request might be ignored due to the Content-Length being set to zero, potentially allowing the smuggled request to be processed.\u003c/p\u003e\n\u003cp\u003eThere are many of possible injections points you can try, there is a great article about it by James Kettle: \u003cstrong\u003e\u003ca href=\"https://portswigger.net/research/http2\"\u003eHTTP/2: The Sequel is Always Worse\u003c/a\u003e\u003c/strong\u003e. In this article i want to just show basic mechanism.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eWe’ve established a solid foundation for understanding HTTP request smuggling. We’ve examined essential HTTP headers, analyzed how discrepancies between front-end and back-end processing can introduce vulnerabilities, and explored both manual and automated methods for detecting these issues. A key aspect of this is understanding the role of Content-Length and Transfer-Encoding in request handling.\u003c/p\u003e\n\u003cp\u003eUnderstanding HTTP/2 request smuggling requires knowledge of how HTTP/2 differs from HTTP/1, particularly in terms of data formatting and transmission. The vulnerability primarily arises from the downgrading process implemented for backward compatibility. By manipulating headers and taking advantage of how different servers interpret requests, attackers can potentially smuggle requests even in HTTP/2 environments.\u003c/p\u003e\n",
      "url": "http://localhost:1313/posts/understanding-request-smuggling/",
      "date_published": "16026-16-09T20:1616:00+00:00",
      "date_modified": "16026-16-09T20:1616:00+00:00",
      "author": {
        "name": "Blazej Gutowski",
        "url": "http://localhost:1313/"
      }
    },
    
    {
      "id": "f21ec4cb9bb6c8e62a50f46c8ab908353b1ba71c",
      "title": "How I Became a Burp Suite Certified Practitioner in 2025: Reflections and Tips",
      "summary": "Discover my journey to becoming a Burp Suite Certified Practitioner in 2025, including lessons learned, challenges faced, and tips for success in cybersecurity.",
      "content_text": "Introduction Did you know that the demand for certified cybersecurity professionals is expected to grow by 35% by 2025? Here’s how I navigated the challenges of becoming a Burp Suite Certified Practitioner and what I learned along the way.\nA Bit About Me To provide some context, let me share my background. I have nearly seven years of experience as an IT administrator, where I managed servers, networks, internal websites, and IT infrastructure. This role has given me a solid understanding of how applications and websites function, from the hardware level through servers and firewalls, all the way to the end user. These fundamentals have allowed me to grasp how web applications operate \u0026ldquo;in the background.\u0026rdquo;\nThroughout my education and career, I\u0026rsquo;ve also dabbled in coding, working on websites, Android apps, and scripts for internal use. While I wouldn\u0026rsquo;t label myself a programmer, I consider myself a capable code reader. I believe these experiences have provided me with a strong foundation to venture into penetration testing.\nWhy This Certification? At a certain point in my career, I felt the need for change. The \u0026ldquo;programming train\u0026rdquo; wasn\u0026rsquo;t appealing to me, and I found it challenging to build a portfolio that would lead to a well-paying job. Inspired by one of my favorite shows, Mr. Robot, I decided to take a leap and explore something new. After conducting a brief market reconnaissance, I set my sights on becoming a penetration tester.\nIn 2023, I began preparing for the OSCP certification but faced setbacks and ultimately didn\u0026rsquo;t pass. However, I decided to take a step back and focus on mastering Burp Suite. But enough about my journey—let\u0026rsquo;s dive into the Burp Suite Exam.\nOutline of the Article In this article, I want to share my experience of passing the Burp Suite Exam. I will provide tips, tricks, and resources that I found helpful along the way, as well as my feelings about the entire process. Whether you\u0026rsquo;re considering this certification or just curious about the world of penetration testing, I hope my insights will be valuable to you.\nPreparation Before diving into the Burp Suite Exam, there are a few essential things you should know. For a comprehensive list of requirements, check out the official PortSwigger certification page.\nOne crucial detail I initially overlooked was the need for a license for the Pro version of Burp Suite. While most of the requirements are relatively low, you will need to budget $449.00 for the Pro version if you don\u0026rsquo;t already have access to it, plus an additional $99 for the exam. If your current job provides access to Burp Suite, you can use that license. According to PortSwigger:\n\u0026ldquo;If you have a Burp Suite Professional license, but it is registered under an email domain of the company you work for rather than your personal email address, you will still be absolutely fine, from a technical perspective, to use that license for taking the exam. So long as you have access to a valid, active Burp Suite Professional license at the time of your certification, you will be able to use it to take the exam.\u0026rdquo;\nIf you have any concerns about using a company-registered license, it\u0026rsquo;s best to discuss this with your employer, as they can provide guidance.\nMaterials Here are the resources I personally utilized during my preparation:\nPortSwigger Topics and Labs: I covered all topics and labs except for the expert level. You can find them here. YouTube Community Solutions: I found valuable insights from channels like: Intigriti Jarno Timmermans PortSwigger Research Articles: These were particularly helpful for understanding concepts like request smuggling. Check them out here. Botesjuan Repository: This is a fantastic resource, especially for learning how to exploit vulnerabilities like XSS to steal cookies rather than just triggering alerts in the browser. You can find it here. Botesjuan YouTube Playlist: This playlist is a great companion resource, with shoutouts to z3nsh3ll and John Hammond. My Own Site: I created a site that mirrors the Botesjuan repository but offers better navigation and includes a section with all payloads. You can visit it here. Study Methods Initial Preparation My study approach was straightforward: I completed all topics and labs except for the expert ones. After that, I revisited and retook topics where I felt less confident, utilizing all the materials mentioned above—sometimes reading through them multiple times. I also tackled several mystery labs and completed a practice exam, which I highly recommend to familiarize yourself with the exam format.\nPortSwigger Methodology Following this, I revisited more mystery labs. You can follow the proposed methodology outlined on the PortSwigger website:\n\u0026ldquo;Work through the topics within the academy, completing every apprentice and practitioner-level lab as you go. As you reach the end of each topic, use the mystery labs feature to practice solving the labs with no contextual clues. When you\u0026rsquo;ve completed all the practitioner-level labs, practice solving mystery labs from all available topics to develop your recon and discovery skills. Then complete a practice exam to familiarize yourself with the exam format. Make sure to read the exam hints and tips, as they contain invaluable information that you\u0026rsquo;ll need to be successful in the exam.\u0026rdquo;\nOvercoming Challenges From my perspective, if a topic seems challenging, revisit it after taking the practice exam and work on it with mystery labs again. This approach helps solidify your understanding and builds confidence in tackling difficult areas.\nTime Commitment I began my preparation in May and passed the exam in January. Throughout this period, I was working full-time and had various personal commitments, including , brithdays, travels and holidays. Therefore, my timeline may not be representative of what others might experience. In hindsight, I believe that 5-6 months is a reasonable timeframe for preparation. However, if you are organized and have more time to dedicate, you could potentially complete it in 3-4 months. Keep in mind that everyone\u0026rsquo;s experience will vary.\nExam Experience The exam consists of two applications that closely resemble those found in the labs. Each application involves three main steps:\nGain access to a standard user account (the username is likely \u0026ldquo;carlos\u0026rdquo;). Elevate privileges to the administrator account. Retrieve the contents of the file located at /home/carlos/secret. For more details, you can read about the exam structure here.\nThe exam duration is four hours.\nMy Tips I passed the exam on my second attempt and discovered various approaches that can be effective. Here are my recommendations:\nStart with Active Scanning: Begin by actively scanning both applications simultaneously. This process may take some time, but it’s worth it. As you explore the websites, generate requests and, if you identify any interesting areas, run a scan for specific insertion points or requests.\nUtilize Two Screens: If possible, set up a dual-screen configuration. Use one larger screen for Burp Suite and the second for your study materials, protocol documentation, and the exam applications. This setup can significantly enhance your workflow.\nBe Aware of Obfuscation Techniques: Remember that the exam may not present obfuscation techniques in the same straightforward manner as the topics covered in the labs. While most labs utilize basic obfuscation, the exam may require you to employ different techniques. Stay alert and be prepared to adapt your strategies accordingly.\nSQL Injection Automation: During my first attempt, I struggled with SQL injection. For the second try I used the CO2 extension, which allows running sqlmap directly in the system terminal. This was a game-changer because it automated the injection process, freeing up my time to focus on other parts of the exam.\nExtensions and Tools Stick to the tools and techniques covered in the PortSwigger Academy topics and labs. Overcomplicating your approach with unfamiliar tools can waste valuable time. But use some time using it, or use some of newer ones like I used CO for SQL Injection.\nReflections Passing the Burp Suite Exam filled me with a profound sense of accomplishment and relief. The journey was challenging, but it ultimately deepened my passion for penetration testing and web security.\nFor those preparing for the exam, I want to emphasize that if you find your motivation waning after months or even years due to your current job, remember that achieving such milestones can reignite your drive. If you have doubts, I assure you that the feeling of passing is incredibly rewarding. I can relate to this personally; I created a blog from scratch and wrote this post in just four days. Two months ago, I would have thought that would take me forever.\nConclusion In summary, my journey to passing the Burp Suite Exam has been both rewarding and enlightening. The key takeaways from this experience include the importance of thorough preparation, the value of utilizing diverse resources, and the necessity of practicing with real-world scenarios.\nLooking ahead, I am eager to deepen my knowledge in the security field. My immediate plan is to gain more experience, hopefully in a new role as a penetration tester, while further developing my skills through CTF platforms and bug bounty programs. I also aspire to attempt the OSCP again and, one day, speak at DEF CON. This professional dream motivates me and provides a boost to my efforts.\nBecoming a Burp Suite Certified Practitioner was one of the most challenging yet rewarding experiences of my career. If I can do it, so can you—start your journey today! If you’re considering becoming a Burp Suite Certified Practitioner, I’d love to hear about your journey. For more tips on cybersecurity, penetration testing, CTFs and bug hunting, follow my blog.\u0026quot;\n",
      "content_html": "\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eDid you know that the demand for certified cybersecurity professionals is expected to grow by 35% by 2025? Here’s how I navigated the challenges of becoming a Burp Suite Certified Practitioner and what I learned along the way.\u003c/p\u003e\n\u003ch3 id=\"a-bit-about-me\"\u003eA Bit About Me\u003c/h3\u003e\n\u003cp\u003eTo provide some context, let me share my background. I have nearly seven years of experience as an IT administrator, where I managed servers, networks, internal websites, and IT infrastructure. This role has given me a solid understanding of how applications and websites function, from the hardware level through servers and firewalls, all the way to the end user. These fundamentals have allowed me to grasp how web applications operate \u0026ldquo;in the background.\u0026rdquo;\u003c/p\u003e\n\u003cp\u003eThroughout my education and career, I\u0026rsquo;ve also dabbled in coding, working on websites, Android apps, and scripts for internal use. While I wouldn\u0026rsquo;t label myself a programmer, I consider myself a capable code reader. I believe these experiences have provided me with a strong foundation to venture into penetration testing.\u003c/p\u003e\n\u003ch3 id=\"why-this-certification\"\u003eWhy This Certification?\u003c/h3\u003e\n\u003cp\u003eAt a certain point in my career, I felt the need for change. The \u0026ldquo;programming train\u0026rdquo; wasn\u0026rsquo;t appealing to me, and I found it challenging to build a portfolio that would lead to a well-paying job. Inspired by one of my favorite shows, \u003cem\u003eMr. Robot\u003c/em\u003e, I decided to take a leap and explore something new. After conducting a brief market reconnaissance, I set my sights on becoming a penetration tester.\u003c/p\u003e\n\u003cp\u003eIn 2023, I began preparing for the OSCP certification but faced setbacks and ultimately didn\u0026rsquo;t pass. However, I decided to take a step back and focus on mastering Burp Suite. But enough about my journey—let\u0026rsquo;s dive into the Burp Suite Exam.\u003c/p\u003e\n\u003ch3 id=\"outline-of-the-article\"\u003eOutline of the Article\u003c/h3\u003e\n\u003cp\u003eIn this article, I want to share my experience of passing the Burp Suite Exam. I will provide tips, tricks, and resources that I found helpful along the way, as well as my feelings about the entire process. Whether you\u0026rsquo;re considering this certification or just curious about the world of penetration testing, I hope my insights will be valuable to you.\u003c/p\u003e\n\u003ch2 id=\"preparation\"\u003ePreparation\u003c/h2\u003e\n\u003cp\u003eBefore diving into the Burp Suite Exam, there are a few essential things you should know. For a comprehensive list of requirements, check out the official \u003ca href=\"https://portswigger.net/web-security/certification/how-it-works#requirements\"\u003ePortSwigger certification page\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eOne crucial detail I initially overlooked was the need for a license for the Pro version of Burp Suite. While most of the requirements are relatively low, you will need to budget $449.00 for the Pro version if you don\u0026rsquo;t already have access to it, plus an additional $99 for the exam. If your current job provides access to Burp Suite, you can use that license. According to PortSwigger:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u0026ldquo;If you have a Burp Suite Professional license, but it is registered under an email domain of the company you work for rather than your personal email address, you will still be absolutely fine, from a technical perspective, to use that license for taking the exam. So long as you have access to a valid, active Burp Suite Professional license at the time of your certification, you will be able to use it to take the exam.\u0026rdquo;\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eIf you have any concerns about using a company-registered license, it\u0026rsquo;s best to discuss this with your employer, as they can provide guidance.\u003c/p\u003e\n\u003ch3 id=\"materials\"\u003eMaterials\u003c/h3\u003e\n\u003cp\u003eHere are the resources I personally utilized during my preparation:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePortSwigger Topics and Labs\u003c/strong\u003e: I covered all topics and labs except for the expert level. You can find them \u003ca href=\"https://portswigger.net/web-security/all-topics\"\u003ehere\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eYouTube Community Solutions\u003c/strong\u003e: I found valuable insights from channels like:\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/@intigriti\"\u003eIntigriti\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/@netletic\"\u003eJarno Timmermans\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePortSwigger Research Articles\u003c/strong\u003e: These were particularly helpful for understanding concepts like request smuggling. Check them out \u003ca href=\"https://portswigger.net/research/articles\"\u003ehere\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eBotesjuan Repository\u003c/strong\u003e: This is a fantastic resource, especially for learning how to exploit vulnerabilities like XSS to steal cookies rather than just triggering alerts in the browser. You can find it \u003ca href=\"https://github.com/botesjuan/Burp-Suite-Certified-Practitioner-Exam-Study\"\u003ehere\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eBotesjuan YouTube Playlist\u003c/strong\u003e: This \u003ca href=\"https://youtube.com/playlist?list=PLsDxQTEdg_YkVMP6PybE7I-hAdhR7adem\u0026amp;si=1UtLwY27vcw5FGT-\"\u003eplaylist\u003c/a\u003e is a great companion resource, with shoutouts to \u003ca href=\"https://www.youtube.com/c/z3nsh3ll\"\u003ez3nsh3ll\u003c/a\u003e and \u003ca href=\"https://www.youtube.com/c/JohnHammond010\"\u003eJohn Hammond\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMy Own Site\u003c/strong\u003e: I created a site that mirrors the Botesjuan repository but offers better navigation and includes a section with all payloads. You can visit it \u003ca href=\"https://oscp-7.gitbook.io/bscp-notes\"\u003ehere\u003c/a\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"study-methods\"\u003eStudy Methods\u003c/h3\u003e\n\u003ch4 id=\"initial-preparation\"\u003eInitial Preparation\u003c/h4\u003e\n\u003cp\u003eMy study approach was straightforward: I completed all topics and labs except for the expert ones. After that, I revisited and retook topics where I felt less confident, utilizing all the materials mentioned above—sometimes reading through them multiple times. I also tackled several mystery labs and completed a practice exam, which I highly recommend to familiarize yourself with the exam format.\u003c/p\u003e\n\u003ch4 id=\"portswigger-methodology\"\u003ePortSwigger Methodology\u003c/h4\u003e\n\u003cp\u003eFollowing this, I revisited more mystery labs. You can follow the proposed methodology outlined on the PortSwigger website:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u0026ldquo;Work through the topics within the academy, completing every apprentice and practitioner-level lab as you go. As you reach the end of each topic, use the mystery labs feature to practice solving the labs with no contextual clues. When you\u0026rsquo;ve completed all the practitioner-level labs, practice solving mystery labs from all available topics to develop your recon and discovery skills. Then complete a practice exam to familiarize yourself with the exam format. Make sure to read the exam hints and tips, as they contain invaluable information that you\u0026rsquo;ll need to be successful in the exam.\u0026rdquo;\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch4 id=\"overcoming-challenges\"\u003eOvercoming Challenges\u003c/h4\u003e\n\u003cp\u003eFrom my perspective, if a topic seems challenging, revisit it after taking the practice exam and work on it with mystery labs again. This approach helps solidify your understanding and builds confidence in tackling difficult areas.\u003c/p\u003e\n\u003ch3 id=\"time-commitment\"\u003eTime Commitment\u003c/h3\u003e\n\u003cp\u003eI began my preparation in May and passed the exam in January. Throughout this period, I was working full-time and had various personal commitments, including , brithdays, travels and holidays. Therefore, my timeline may not be representative of what others might experience. In hindsight, I believe that 5-6 months is a reasonable timeframe for preparation. However, if you are organized and have more time to dedicate, you could potentially complete it in 3-4 months. Keep in mind that everyone\u0026rsquo;s experience will vary.\u003c/p\u003e\n\u003ch2 id=\"exam-experience\"\u003eExam Experience\u003c/h2\u003e\n\u003cp\u003eThe exam consists of two applications that closely resemble those found in the labs. Each application involves three main steps:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eGain access to a standard user account (the username is likely \u0026ldquo;carlos\u0026rdquo;).\u003c/li\u003e\n\u003cli\u003eElevate privileges to the administrator account.\u003c/li\u003e\n\u003cli\u003eRetrieve the contents of the file located at \u003ccode\u003e/home/carlos/secret\u003c/code\u003e.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eFor more details, you can read about the exam structure \u003ca href=\"https://portswigger.net/web-security/certification/how-it-works#what-the-exam-involves\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThe exam duration is four hours.\u003c/p\u003e\n\u003ch3 id=\"my-tips\"\u003eMy Tips\u003c/h3\u003e\n\u003cp\u003eI passed the exam on my second attempt and discovered various approaches that can be effective. Here are my recommendations:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eStart with Active Scanning\u003c/strong\u003e: Begin by actively scanning both applications simultaneously. This process may take some time, but it’s worth it. As you explore the websites, generate requests and, if you identify any interesting areas, run a scan for specific insertion points or requests.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eUtilize Two Screens\u003c/strong\u003e: If possible, set up a dual-screen configuration. Use one larger screen for Burp Suite and the second for your study materials, protocol documentation, and the exam applications. This setup can significantly enhance your workflow.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eBe Aware of Obfuscation Techniques\u003c/strong\u003e: Remember that the exam may not present obfuscation techniques in the same straightforward manner as the topics covered in the labs. While most labs utilize basic obfuscation, the exam may require you to employ different techniques. Stay alert and be prepared to adapt your strategies accordingly.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eSQL Injection Automation\u003c/strong\u003e: During my first attempt, I struggled with \u003cstrong\u003eSQL injection\u003c/strong\u003e. For the second try I used the \u003cstrong\u003eCO2 extension\u003c/strong\u003e, which allows running \u003cstrong\u003esqlmap\u003c/strong\u003e directly in the system terminal. This was a game-changer because it automated the injection process, freeing up my time to focus on other parts of the exam.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eExtensions and Tools\u003c/strong\u003e Stick to the tools and techniques covered in the \u003cstrong\u003ePortSwigger Academy topics and labs\u003c/strong\u003e. Overcomplicating your approach with unfamiliar tools can waste valuable time. But use some time using it, or use some of newer ones like I used CO for SQL Injection.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"reflections\"\u003eReflections\u003c/h2\u003e\n\u003cp\u003ePassing the Burp Suite Exam filled me with a profound sense of accomplishment and relief. The journey was challenging, but it ultimately deepened my passion for penetration testing and web security.\u003c/p\u003e\n\u003cp\u003eFor those preparing for the exam, I want to emphasize that if you find your motivation waning after months or even years due to your current job, remember that achieving such milestones can reignite your drive. If you have doubts, I assure you that the feeling of passing is incredibly rewarding. I can relate to this personally; I created a blog from scratch and wrote this post in just four days. Two months ago, I would have thought that would take me forever.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eIn summary, my journey to passing the \u003ca href=\"https://portswigger.net/web-security/e/c/690adbbe21505dc3\"\u003eBurp Suite Exam\u003c/a\u003e has been both rewarding and enlightening. The key takeaways from this experience include the importance of thorough preparation, the value of utilizing diverse resources, and the necessity of practicing with real-world scenarios.\u003c/p\u003e\n\u003cp\u003eLooking ahead, I am eager to deepen my knowledge in the security field. My immediate plan is to gain more experience, hopefully in a new role as a penetration tester, while further developing my skills through CTF platforms and bug bounty programs. I also aspire to attempt the OSCP again and, one day, speak at DEF CON. This professional dream motivates me and provides a boost to my efforts.\u003c/p\u003e\n\u003cp\u003eBecoming a Burp Suite Certified Practitioner was one of the most challenging yet rewarding experiences of my career. If I can do it, so can you—start your journey today! If you’re considering becoming a Burp Suite Certified Practitioner, I’d love to hear about your journey. For more tips on cybersecurity, penetration testing, CTFs and bug hunting, follow my blog.\u0026quot;\u003c/p\u003e\n",
      "url": "http://localhost:1313/posts/bscp-reflections-and-tips/",
      "date_published": "22016-22-09T10:2222:00+00:00",
      "date_modified": "22016-22-09T10:2222:00+00:00",
      "author": {
        "name": "Blazej Gutowski",
        "url": "http://localhost:1313/"
      }
    }
    
  ]
}